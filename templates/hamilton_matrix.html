<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bson/4.7.2/bson.bundle.min.js"></script>
    <title>Hamilton Matrix 3D Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            z-index: 100;
        }
        #controls input {
            margin: 5px 0;
        }
        #controls button {
            margin: 5px;
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        #controls button:hover {
            background: #666;
        }
        #fileSelector {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 120px;
        }
        select {
            padding: 5px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
        }
        canvas {
            display: block;
        }
        #loadingIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            display: none;
        }
        #matrixDetails {
            margin-top: 10px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Hamilton Matrix Visualization</h2>
        <div id="matrixInfo">Matrix: Not loaded</div>
        <div id="sectionInfo">Section: Not selected</div>
        <div id="matrixDetails"></div>
    </div>

    <div id="controls">
        <div>
            <label for="fileSelector">Field Strength:</label>
            <select id="fileSelector">
                <option value="hamilton_matrix_B0.000T.npz">B = 0.000 T</option>
                <option value="hamilton_matrix_B2500.000T.npz">B = 2500.000 T</option>
                <option value="hamilton_matrix_B5000.000T.npz">B = 5000.000 T</option>
            </select>
        </div>
        <div>
            <label for="startRow">Start Row:</label>
            <input type="number" id="startRow" min="0" value="0" style="width: 60px">
        </div>
        <div>
            <label for="startCol">Start Column:</label>
            <input type="number" id="startCol" min="0" value="0" style="width: 60px">
        </div>
        <div>
            <label for="sectionSize">Section Size:</label>
            <input type="number" id="sectionSize" min="1" max="20" value="10" style="width: 60px">
        </div>
        <div>
            <label for="amplify">Amplify Height:</label>
            <input type="range" id="amplify" min="0.1" max="10" step="0.1" value="3" style="width: 120px">
            <span id="amplify-value">3.0</span>
        </div>
        <div>
            <label for="skipSmall">Skip Small Values:</label>
            <input type="checkbox" id="skipSmall" checked>
        </div>
        <div>
            <button id="loadMatrixBtn">Load Matrix</button>
            <button id="resetViewBtn">Reset View</button>
        </div>
    </div>

    <div id="loadingIndicator">Loading matrix data...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Scene setup
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f0f0f);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
        light1.position.set(1, 1, 1);
        scene.add(light1);

        const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
        light2.position.set(-1, 0.5, -1);
        scene.add(light2);

        // Add grid
        const gridHelper = new THREE.GridHelper(20, 20);
        scene.add(gridHelper);

        // Add axes
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);

        // State
        let currentMatrixData = null;
        let matrixBars = new THREE.Group();
        scene.add(matrixBars);

        // DOM elements
        const fileSelector = document.getElementById('fileSelector');
        const startRowInput = document.getElementById('startRow');
        const startColInput = document.getElementById('startCol');
        const sectionSizeInput = document.getElementById('sectionSize');
        const amplifyInput = document.getElementById('amplify');
        const skipSmallInput = document.getElementById('skipSmall');
        const loadMatrixBtn = document.getElementById('loadMatrixBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const matrixInfoDiv = document.getElementById('matrixInfo');
        const sectionInfoDiv = document.getElementById('sectionInfo');
        const matrixDetailsDiv = document.getElementById('matrixDetails');
        const loadingIndicator = document.getElementById('loadingIndicator');

        // Add event listener for amplify slider
        amplifyInput.addEventListener('input', function(e) {
            document.getElementById('amplify-value').textContent = parseFloat(e.target.value).toFixed(1);
        });

        // Load matrix data from server
        async function loadMatrixData(filename) {
            loadingIndicator.style.display = 'block';

            try {
                // Check if we have a .bson version of this file
                const bsonFilename = filename.replace('.npz', '.bson');

                try {
                    // Try to load the BSON version first (faster)
                    const response = await fetch(`/api/bson_matrix/${bsonFilename}`);

                    if (response.ok) {
                        // If BSON file exists, use it
                        const arrayBuffer = await response.arrayBuffer();
                        const data = BSON.deserialize(new Uint8Array(arrayBuffer));

                        // Convert to the expected format
                        const result = {
                            filename: data.filename,
                            size: [data.H.length, data.H[0].length],
                            matrix: data.H,
                            B_tesla: data.B_tesla,
                            B_au: data.B_au,
                            timestamp: data.timestamp,
                            metadata: data.metadata
                        };

                        loadingIndicator.style.display = 'none';
                        return result;
                    }
                } catch (error) {
                    console.log('BSON format not available, falling back to NPZ');
                }

                // Fall back to NPZ format if BSON is not available
                const npzResponse = await fetch(`/api/matrix/${filename}`);
                if (!npzResponse.ok) {
                    throw new Error(`Failed to load matrix: ${filename}`);
                }

                const data = await npzResponse.json();
                loadingIndicator.style.display = 'none';
                return data;
            } catch (error) {
                console.error('Error loading matrix:', error);
                loadingIndicator.style.display = 'none';
                return null;
            }
        }

        // Extract section from matrix
        function extractMatrixSection(matrixData, startRow, startCol, size) {
            const section = [];
            const matrix = matrixData.matrix;

            for (let i = 0; i < size; i++) {
                const row = [];
                for (let j = 0; j < size; j++) {
                    const r = startRow + i;
                    const c = startCol + j;

                    if (r < matrix.length && c < matrix[0].length) {
                        row.push(matrix[r][c]);
                    } else {
                        row.push(0); // Out of bounds
                    }
                }
                section.push(row);
            }

            return section;
        }

        // Visualize matrix section with 3D bars
        function visualizeMatrixSection(section, amplifyFactor = 3) {
            // Clear previous visualization
            scene.remove(matrixBars);
            matrixBars = new THREE.Group();

            const size = section.length;
            const skipSmall = document.getElementById('skipSmall').checked;

            // Find min and max values for color scaling
            let minVal = Infinity;
            let maxVal = -Infinity;

            // First pass to determine min/max for normalization
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const value = Math.abs(section[i][j]);
                    if (value < minVal && value > 0.001) minVal = value;
                    if (value > maxVal) maxVal = value;
                }
            }

            // Set threshold based on max value
            const threshold = maxVal * 0.05; // Skip values less than 5% of max

            // Create merged geometries for better performance
            const geometries = [];
            const materials = [];
            const positions = [];

            // Create bars for each matrix element
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const value = section[i][j];
                    const absValue = Math.abs(value);

                    // Skip very small values if checkbox is checked
                    if (skipSmall && absValue < threshold) continue;

                    // Calculate shorter height
                    const height = absValue * amplifyFactor;

                    // Calculate normalized value for color
                    const normalizedValue = (absValue - minVal) / (maxVal - minVal);

                    // Create color: blue (small) to red (large)
                    const color = new THREE.Color();
                    color.r = normalizedValue;
                    color.g = 0;
                    color.b = 1 - normalizedValue;

                    // Create box geometry
                    const geometry = new THREE.BoxGeometry(0.8, height, 0.8);

                    // Position the geometry
                    const x = j - size/2;
                    const z = i - size/2;
                    const y = height / 2;

                    // Translate geometry to correct position
                    geometry.translate(x, y, z);

                    // Store for merging
                    geometries.push(geometry);

                    // Create and store material
                    materials.push(new THREE.MeshPhongMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.8 + normalizedValue * 0.2
                    }));
                }
            }

            // Create meshes in batches for better performance
            const batchSize = Math.min(100, geometries.length);
            for (let i = 0; i < geometries.length; i += batchSize) {
                const batchEnd = Math.min(i + batchSize, geometries.length);
                const batchGeometries = geometries.slice(i, batchEnd);
                const batchMaterials = materials.slice(i, batchEnd);

                // Create merged geometry for this batch
                for (let j = 0; j < batchGeometries.length; j++) {
                    const mesh = new THREE.Mesh(batchGeometries[j], batchMaterials[j]);
                    matrixBars.add(mesh);
                }
            }

            scene.add(matrixBars);
        }

        // Format matrix details for display
        function formatMatrixDetails(data) {
            if (!data) return "";

            let details = `<strong>B-Field:</strong> ${data.B_tesla} T<br>`;
            details += `<strong>B (a.u.):</strong> ${data.B_au}<br>`;
            details += `<strong>Timestamp:</strong> ${data.timestamp}<br>`;

            // Add metadata if available
            if (data.metadata) {
                try {
                    // If metadata is already an object, use it directly
                    const meta = typeof data.metadata === 'string'
                        ? JSON.parse(data.metadata)
                        : data.metadata;

                    if (Object.keys(meta).length > 0) {
                        details += "<strong>Metadata:</strong><br>";
                        for (const [key, value] of Object.entries(meta)) {
                            details += `- ${key}: ${value}<br>`;
                        }
                    }
                } catch (e) {
                    console.error("Error parsing metadata:", e);
                }
            }

            return details;
        }

        // Handle matrix loading and visualization
        async function loadAndVisualizeMatrix() {
            const filename = fileSelector.value;
            const startRow = parseInt(startRowInput.value);
            const startCol = parseInt(startColInput.value);
            const sectionSize = parseInt(sectionSizeInput.value);
            const amplifyFactor = parseFloat(amplifyInput.value);
            document.getElementById('amplify-value').textContent = amplifyFactor.toFixed(1);

            // Load matrix data
            currentMatrixData = await loadMatrixData(filename);

            if (currentMatrixData) {
                // Update info
                matrixInfoDiv.textContent = `Matrix: ${filename}`;
                sectionInfoDiv.textContent = `Section: [${startRow}:${startRow+sectionSize}, ${startCol}:${startCol+sectionSize}]`;

                // Show matrix size from the size property (which is now a shape array)
                const matrixShape = currentMatrixData.size;
                const matrixSize = Array.isArray(matrixShape)
                    ? `${matrixShape[0]}x${matrixShape[1]}`
                    : matrixShape;

                matrixInfoDiv.textContent += ` (${matrixSize})`;

                // Update matrix details
                matrixDetailsDiv.innerHTML = formatMatrixDetails(currentMatrixData);

                // Extract section
                const section = extractMatrixSection(currentMatrixData, startRow, startCol, sectionSize);

                // Visualize section
                visualizeMatrixSection(section, amplifyFactor);
            }
        }

        // Reset camera view
        function resetView() {
            camera.position.set(15, 15, 15);
            camera.lookAt(0, 0, 0);
        }

        // Event listeners
        loadMatrixBtn.addEventListener('click', loadAndVisualizeMatrix);
        resetViewBtn.addEventListener('click', resetView);

        // Custom OrbitControls implementation
        class OrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3();

                this.rotateSpeed = 1.0;
                this.zoomSpeed = 1.0;

                this.minDistance = 5;
                this.maxDistance = 50;

                this.STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };
                this.state = this.STATE.NONE;

                // Mouse Events
                this.domElement.addEventListener('mousedown', this.onPointerDown.bind(this));
                this.domElement.addEventListener('mousemove', this.onPointerMove.bind(this));
                this.domElement.addEventListener('mouseup', this.onPointerUp.bind(this));
                this.domElement.addEventListener('mouseleave', this.onPointerUp.bind(this));

                // Touch Events
                this.domElement.addEventListener('touchstart', this.onTouchStart.bind(this));
                this.domElement.addEventListener('touchmove', this.onTouchMove.bind(this));
                this.domElement.addEventListener('touchend', this.onPointerUp.bind(this));

                // Zoom Events
                this.domElement.addEventListener('wheel', this.onWheel.bind(this));
            }

            onPointerDown(event) {
                event.preventDefault();

                if (event.button === 0) { // Left mouse button
                    this.state = this.STATE.ROTATE;
                } else if (event.button === 1) { // Middle mouse button
                    this.state = this.STATE.ZOOM;
                } else if (event.button === 2) { // Right mouse button
                    this.state = this.STATE.PAN;
                }

                this.startPoint = {
                    x: event.clientX,
                    y: event.clientY
                };
            }

            onTouchStart(event) {
                event.preventDefault();

                if (event.touches.length === 1) {
                    this.state = this.STATE.ROTATE;
                    this.startPoint = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };
                } else if (event.touches.length === 2) {
                    this.state = this.STATE.ZOOM;
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    this.startDistance = Math.sqrt(dx * dx + dy * dy);
                }
            }

            onPointerMove(event) {
                if (this.state === this.STATE.ROTATE) {
                    const deltaX = (event.clientX - this.startPoint.x) * 0.01;
                    const deltaY = (event.clientY - this.startPoint.y) * 0.01;

                    this.rotate(deltaX, deltaY);

                    this.startPoint = {
                        x: event.clientX,
                        y: event.clientY
                    };
                } else if (this.state === this.STATE.PAN) {
                    // Add panning if needed
                }
            }

            onTouchMove(event) {
                event.preventDefault();

                if (this.state === this.STATE.ROTATE && event.touches.length === 1) {
                    const deltaX = (event.touches[0].clientX - this.startPoint.x) * 0.01;
                    const deltaY = (event.touches[0].clientY - this.startPoint.y) * 0.01;

                    this.rotate(deltaX, deltaY);

                    this.startPoint = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    };
                } else if (this.state === this.STATE.ZOOM && event.touches.length === 2) {
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    const delta = (distance - this.startDistance) * 0.01;
                    this.zoom(delta);

                    this.startDistance = distance;
                }
            }

            onPointerUp() {
                this.state = this.STATE.NONE;
            }

            onWheel(event) {
                event.preventDefault();

                const delta = -Math.sign(event.deltaY) * 0.1;
                this.zoom(delta);
            }

            rotate(deltaX, deltaY) {
                // Create rotation matrices
                const rotationMatrixY = new THREE.Matrix4().makeRotationY(-deltaX * this.rotateSpeed);
                const rotationMatrixX = new THREE.Matrix4().makeRotationX(-deltaY * this.rotateSpeed);

                // Get direction vector from camera to target
                const offset = new THREE.Vector3().subVectors(this.camera.position, this.target);

                // Apply rotations
                offset.applyMatrix4(rotationMatrixY);
                offset.applyMatrix4(rotationMatrixX);

                // Set new camera position
                this.camera.position.copy(this.target).add(offset);

                // Make camera look at target
                this.camera.lookAt(this.target);
            }

            zoom(delta) {
                // Get direction vector from camera to target
                const offset = new THREE.Vector3().subVectors(this.camera.position, this.target);

                // Calculate new distance
                const currentDistance = offset.length();
                const newDistance = currentDistance * (1 - delta);

                // Apply distance limits
                if (newDistance >= this.minDistance && newDistance <= this.maxDistance) {
                    // Scale the offset vector
                    offset.multiplyScalar(1 - delta);

                    // Set new camera position
                    this.camera.position.copy(this.target).add(offset);
                }
            }

            update() {
                // Nothing needed here for this implementation
                return true;
            }
        }

        // Initialize controls
        const controls = new OrbitControls(camera, renderer.domElement);

        // Animate - without automatic rotation
        function animate() {
            requestAnimationFrame(animate);
            // Render the scene
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize visualization
        loadAndVisualizeMatrix();
        animate();
    </script>
</body>
</html>